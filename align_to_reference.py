#!/usr/bin/env python3

import os
from Bio import SeqIO
import tempfile
import subprocess



"""
if mutation is within the range of a features (CDS, rRNA, tRNA etc): note that,
if mutation is within CDS, get the change in AA sequence(if any)
save the stuff in the metadata
if MGE then just do normal BLAST and look for hits:
if hits, write the coordinates to the metadata file
"""
def makeblastdb(gen, direct):
	"""
	Make blastn database from the genbank file.
	
	Parameters
	----------
	gen: str, path.PATH
		path to the genbank file
	direct: str, path.PATH
		path to directory where the database will be created

	returns
	-------
	fa_file: str
		path to the newly created blasn database
	"""
	fa_file = os.path.join(direct, name + '.fasta')
	with open(fa_file, 'w') as fout:
		for refseq in SeqIO.parse(gen, 'genbank'):
			fout.write(f'>{refseq.id}\n{refseq.seq}\n')
	#dst = os.path.join(direct, os.path.basename(fa_file))
	#copyfile(fa_file, dst)
	db_call = ['makeblastdb', '-dbtype', 'nucl', '-in', dst]
	with open(os.devnull, 'w') as null_buffer:
		subprocess.call(db_call, stdout=null_buffer)
	return fa_file 

def runblast(fa, db, name):
	"""
	Run blastn between the reference database and the component fasta file
	
	Parameters
	----------
	fa: str, path.PATH
		path to the component fasta file
	db: str, path.PATH
		path to the database file
	"""
	global outfmt
	outfmt = "6 qseqid sseqid pident length mismatch gapopen qstart qend sstart send evalue bitscore qcovs"
	blast_call = ['blastn', '-db', db, '-query', fa, '-max_target_seqs', '1', '-outfmt', outfmt]
	outfile = os.path.join(direct, name + '.txt'
	with open(outfile, 'w') as tout:
		tout.write(subprocess.check_output(blast_call).decode('utf-8'))
	return outfile

def process_blastout(blast_out, pheno):
	"""
	Parse blast results to find the DBGWAS sequences that match the reference genome
	
	Parameters
	----------
	blast_out: str, path.PATH
		path to the blast result (outfmt 6)

	returns
	-------
	blast_df: pandas.DataFrame
		pandas dataframe containing the sequence info for those that mapped to the reference
	"""

	blast_df = pd.read_csv(blast_out, sep='\t', header=None, names=outfmt.split()[1:]) #outfmt from runblast
	blast_df = blast_df[blast_df.qseqid.str.contains(pheno)]
	# sort by bitscore so when duplicated is dropped, the one with highest is kept
	blast_df.sort_values('bitscore', ascending=False, inplace=True)
	blast_df.drop_duplicates(subset=['qseqid'], inplace=True)
	keep_idx = np.concatenate((_mge_match(df)[0], _cycles_match(df)[0]))
	blast_df = blast_df.loc[keep_idx]
	return blast_df

def _mge_match(df):
	"returns index of sequences that match MGE criteria"
    return np.where((df.qseqid.str.contains('MGE') &
                    (df.pident >= 80.0) &
                    (df.qcovs >= 80.0)))

def _cycles_match(df):
	"returns index of cycle sequences that match the reference genome"
    return np.where((df.qseqid.str.contains('cycle')) &
            (df.pident == 100.0) &
            (df.qcovs  == 100.0))

def map_blast(blast_df, md_df, name):
	"""
	Add the sequence info from the blast data to the metadata
	
	Parameters
	----------
	blast_df: pandas.DataFrame
		pandas dataframe containing aln info from mapped DBGWAS sequences (outfmt 6)
	md_df: pandas.DataFrame
        pandas dataframe containing the DBGWAS sequence metadata
	"""
	# for the all sequences there, map (start, end) -> 'pos' 
	
def mapcyclefeatures(md, feats, name):
	
	
	
def mapfeatures(gb, md, blast_df,  name):
	"""
	Finds if the DBGWAS enriched sequences aligned to the reference overlaps any features (e.g. CDS, tRNA, rRNA etc.)
	
	Parameters
	----------
	gff: str, path.PATH
		path to the gff3 file containing the feature info
	md: pd.DataFrame
		pandas dataframe containing the DBGWAS sequence metadata
	"""	
	feats = getfeatures(gb)
	
	mapMGEfeature(md, name)
	# should return the positions of the mutations
	mapcyclefeature(md, name)
	
	
def getfeatures(gb):
	""" Get all the information about different features in the genbank files"""
	feats = []
	for rs in SeqIO.parse(gb, 'genbank'):
		for feat in rs.features:
			if feat.type in ['gene', 'source']:
				continue
			# locus_tag, ftype, start, end
			try:
				locus_tag = feat.qualifiers['locus_tag']
			except KeyError:
				locus_tag = 'Unknown feature'
			feats.append([locus_tag, feat.type, feat.location.start,
						  feat.location.end, feat.location.strand]
	return feats
						

	
if __name__ == '__main__':
	print("UNDER CONSTRUCTION; COME BACK LATER")
	
	import argparse
	p = argparse.ArgumentParser(description='Annotate the mutations using reference genomes. The annotations are updated in the input\
								metadata file.')
	p.add_argument('fa', help='path to fasta file containing the path and MGE sequences. Generated by component_analysis.py',
					type=str)
	p.add_argument('md', help='path to metadata file containing sequnece metadata. Generated by component_analysis.py',
					type=str)
	p.add_argument('-r', '--ref', help='Reference genbank files used to annotate the sequences. Must be reference sequence for pheno0 followed by reference for pheno1',
				    required=True, nargs='+')
	p.add_argument('-p', '--pheno', help='Whether the references passed in -r are from pheno0 or pheno1. Must pass same number of values as number of references e.g. "-p pheno0 pheno1"',
				    requied=True, nargs='+') 
	params = vars(p.parse_args())
	
	if len(params['ref'] != 2):
		raise ValueError(f'Must provide 2 reference genomes, one for pheno0 and one for pheno1 in that order. {len(params["feat"])} genomes provided instead')
	
	md_df = pd.read_csv(params['md'], index_col=0)
	if 'mutations' not in md_df.columns:
		raise AttributeError('"Mutations" column not found in metadata. Run "sequence_analysis.py" first')
		
	if len(params['pheno']) != len(params['ref']):
		raise ValueError('Different number of reference and phenotypes passed. Recheck number of params passed to "-r" and "-p."' 
	with tempfile.TemporaryDirectory() as tempdir:
		for pheno, gen in zip(params['pheno'], params['ref']):
			name = os.path.basename(gen).split('.')[0]
			db_file = makeblastdb(gen, tempdir)
			blast_outfile = runblast(gen, db, name)
			matched_seq = process_blastout(blast_outfile, pheno)
			map_blast(matched_seq, md_df, name) 
			
		
			
